//////////////////////////////////////////////////////////////////
In my model I have now generated a signal and background with differet mass sitributions. Also I have constructed an angle Phi which in the case of the signal has a polarisation depedent cos(2Phi) distribution. It is necessary to save the polarisation state as in integer PolState for use in the fit PDF, in general this should be -1,0,1, as well as the magnitude of polarisation as a seperate double. Note the polarisation is Egamma dependent and so must be handled event by event.
////////////////////////////////////////////////////////////////////
To generate data
root 'Model1.C( "Data.root" )'
To Generate MC data for normalisation integral calculation
root 'Model1.C( "MC.root",0 )'

//////////////////////////////////////////////////////////////////
Background Subtraction
First I need to perform an sPlot fit to extract signal from background. This is exactly the same as for testSimple so heere I just copy the code to perform this in bins. This is file FitHSSimpleBins.C and you should be able to just run with root --hsfit FitHSSimpleBins.C. This will perform 4 fits split in Eg and save the results and weights in outSignal
//////////////////////////////////////////////////////////////////////
Fitting Observable
Making a new PDF class
Make a PDF class called PhiAsymmetry which depends on variable Phi and in addition the magitude of polarisation Pol and the polarisation state PolState, both of which are also recoreded in the tree. It has 2 fit parameters A and B which will be the cos and sin coefficeients respectively.

RooFit autogenerate custom pdf classes via the RooClassFactory. Here we extend this to pdfs inheriting from RooHSAbsEventsPDF - the class that handles simulated event trees for PDF integration and model event generation.
To make the skeleton code we use the THSSkeleton class :
   root --THSSkeleton.C
   root [1] THSSkeleton skel;
   root [2] skel.CreateRooFitEventsPDF("SKNewPDF","Phi,Pol,CAT:PolState","A,B")

This creates a PDF that will fit variables in the input tree called Phi and Pol, with a RooCategory PolState (for asymmmetries) and with fit parameters called A and B. The user now has to define the fit function themselves. Open MyNewPDF.cxx; scrolll down to the evaluate() function (Nothing else should need edited) Replace the default return 1.0; with a suitable fit function :
Double_t MyNewPDF::evaluate() const 
 { 
  return 1.0 + PolState*Pol*(A*TMath::Cos(2*TMath::DegToRad()*Phi)+B*TMath::Sin(2*TMath::DegToRad()*Phi));
 } 
Similar for evaluateMC() :

Double_t MyNewPDF::evaluateMC() const {
// ENTER IDENTICAL EXPRESSION TO evaluate() IN TERMS OF MC VARIABLE ARGUMENTS HERE
  Double_t mcPhi=(*vars)[fTreeEntry*fNvars+0];
  Double_t mcPol=(*vars)[fTreeEntry*fNvars+1];
  Int_t mcPolState=(*cats)[fTreeEntry*fNcats+0];
  return 1.0 + mcPolState*mcPol*(A*TMath::Cos(2*TMath::DegToRad()*mcPhi)+B*TMath::Sin(2*TMath::DegToRad()*mcPhi)); 
}

Note the lines Double_t mcPhi=fvecReal[fTreeEntry*fNvars+0]; are generated by the skelton code
Note the only difference between the functions is Phi->mcPhi and Pol->mcPol

That should be the PDF completed.
//////////////////////////////////////////////////////////////////////////


The form of the function is given in the Model1.C file which generated the events :
 TF1* fPhip=new TF1("phip","1+[2]*([0]*cos(2*TMath::DegToRad()*x)+[1]*sin(2*TMath::DegToRad()*x))",-180,180);



///////////////////////////////////////////////////////////////////
Fit macro FitHSAsymmetry.C
#To run root --hsfit FitHSAsymmetry.C --PhiAsymmetry.cxx
OR to run with generated MC integration
 root --hsfit FitHSAsymmetryMCInt.C --PhiAsymmetry.cxx
 
Details given below
Note it is a slightly different manager class when not using sWeights as much of the functionality is not required. Here we use the base interface class
  THSRooFit* RF=new THSRooFit("AFit");

To make a binned fit we split the data using MakeBinnedTree
  RF->LoadBinVars("Mmiss",1,0,10);//for consistency same range as signal fit
  RF->LoadBinVars("Eg",4,3,4);//here use smae energy bins

  ///////////////////////////Load Data
  TChain chain("MyModel");
  chain.AddFile("Data.root");
  RF->SetIDBranchName("fgID");
  //////////////////////////////Split data into bins and load them
  RF->MakeBinnedTrees(&chain,"Data");
  RF->ConfigureSavedBins(RF->GetOutDir());

ConfigureSavedBins then reloads the binned tree.

Declare the new PDF for fitting with. The fit parameters are A and B which are restricted between -1 and 1
  RF->Factory("PhiAsymmetry::SigAsym( Phi,Pol,PolState,A[0,-1,1],B[0,-1,1] )");

The weights from the previous sPlot step should be attached to the data set :
  RF->LoadWeights("outWeights/WeightsbinFit.root ","WeightMap");
  RF->SetWeightName("Signal"); //Same as Signal species in FitHSSimpleBins

To run the fit now use the FitSavedBins function rather than RunWeights
 RF->FitSavedBins(1);//argument gives number of parameter fits to perform
 
